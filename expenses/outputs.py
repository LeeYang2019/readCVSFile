"""Output generation helpers."""

from __future__ import annotations

import os
from typing import List, Dict, Tuple

import pandas as pd
import csv


def slugify(name: str) -> str:
    """
    Convert category name to safe filename.
    
    Removes/replaces special characters that are problematic in filenames.
    Example: "Food & Dining" → "food_dining"
    
    Args:
        name: Category name or any string
        
    Returns:
        Filename-safe string with alphanumerics, dots, hyphens, underscores only
    """
    sanitized = name.strip()
    # Keep only alphanumerics, dots, hyphens, underscores; replace others with underscore
    sanitized = "".join(ch if ch.isalnum() or ch in "._-" else "_" for ch in sanitized)
    sanitized = sanitized.strip("_")  # Remove leading/trailing underscores
    return sanitized or "uncategorized"


def write_outputs(base_dir: str, base_name: str, df_subset: pd.DataFrame, detail_cols: List[str]) -> str:
    """
    Generate expense summary and detail CSV files.
    
    Creates two types of outputs:
    1. Master summary: All transactions grouped by (Category, Description) with counts and totals
    2. Per-category detail tables: Breakdown of each category with transaction details and summaries
    
    Structure:
    - base_dir/expenses_outputs/{base_name}_summary_expenses.csv (master)
    - base_dir/expenses_outputs/{base_name}_category_tables/{category}_detail.csv (per-file details)
    - base_dir/expenses_outputs/{base_name}_category_tables/{category}_summary.csv (per-category summary)
    
    Args:
        base_dir: Base output directory
        base_name: Base filename (e.g., "chase_checking" or "combined_20251212_150000")
        df_subset: Expense DataFrame to summarize
        detail_cols: Column names to include in detail tables
        
    Returns:
        Path to expenses_outputs directory (root of all generated files)
    """
    # Create main output directory
    out_root = os.path.join(base_dir, "expenses_outputs")
    os.makedirs(out_root, exist_ok=True)

    # Generate master summary: group by category and description
    # Include CategoryGroup in the master summary so grouping is explicit
    if "CategoryGroup" in df_subset.columns:
        summary = (
            df_subset.groupby(["CategoryGroup", "Category", "_description_clean"], dropna=False)
            .agg(count=("_description_clean", "count"), total_amount=("_signed_amount", "sum"))
            .reset_index()
            .rename(columns={"_description_clean": "Description"})
            .sort_values(["CategoryGroup", "Category", "total_amount", "Description"], ascending=[True, True, False, True])
        )
    else:
        summary = (
            df_subset.groupby(["Category", "_description_clean"], dropna=False)
            .agg(count=("_description_clean", "count"), total_amount=("_signed_amount", "sum"))
            .reset_index()
            .rename(columns={"_description_clean": "Description"})
            .sort_values(["Category", "total_amount", "Description"], ascending=[True, False, True])
        )
    # Add totals row
    totals = pd.DataFrame(
        {
            "Category": ["__ALL__"],
            "Description": ["__TOTAL__"],
            "count": [summary["count"].sum()],
            "total_amount": [summary["total_amount"].sum()],
        }
    )
    summary_with_total = pd.concat([summary, totals], ignore_index=True)
    master_out = os.path.join(out_root, f"{base_name}_summary_expenses.csv")
    summary_with_total.to_csv(master_out, index=False)
    print(f"[OK] Wrote master summary to: {master_out}")

    # Per-category tables generation removed to reduce output clutter.
    # The master summary remains; grouped tables are generated by
    # `write_grouped_category_outputs` when invoked from the runner.
    print(f"[OK] Wrote master summary to: {master_out}")
    return out_root


# Monthly grouping feature removed per user's request.
# The code previously generated monthly summary and per-month details.
# If you want the monthly outputs back later, reintroduce `write_monthly_outputs`.


def write_grouped_category_outputs(base_dir: str, base_name: str, df_subset: pd.DataFrame, detail_cols: List[str]) -> str:
    """
    Generate expense summaries grouped by CategoryGroup (Travel, Household, etc).
    
    Preserves the original Category names (Gas/Automotive, Lodging, Coffee, etc.) 
    in the output files while organizing by broader groups.
    
    Creates:
    - Master summary: All transactions grouped by (CategoryGroup, Description) 
    - Per-group detail tables: Transactions organized by group but showing original Category
    
    Structure:
    - base_dir/expenses_outputs/{base_name}_grouped_summary.csv (master)
    - base_dir/expenses_outputs/{base_name}_grouped_tables/{group}_detail.csv
    - base_dir/expenses_outputs/{base_name}_grouped_tables/{group}_category_summary.csv
    
    Args:
        base_dir: Base output directory
        base_name: Base filename
        df_subset: Expense DataFrame with Category and CategoryGroup columns
        detail_cols: Column names to include in detail tables
        
    Returns:
        Path to expenses_outputs directory
    """
    # Create main output directory
    out_root = os.path.join(base_dir, "expenses_outputs")
    os.makedirs(out_root, exist_ok=True)

    # Check if CategoryGroup column exists
    if "CategoryGroup" not in df_subset.columns:
        print("[WARN] CategoryGroup column not found; skipping grouped outputs")
        return out_root

    # Generate master summary: group by category group and description (preserving original Category)
    summary = (
        df_subset.groupby(["CategoryGroup", "CategoryOriginal" if "CategoryOriginal" in df_subset.columns else "Category", "_description_clean"], dropna=False)
        .agg(count=("_description_clean", "count"), total_amount=("_signed_amount", "sum"))
        .reset_index()
        .rename(columns={"_description_clean": "Description"})
    )
    # Rename the category column for consistency
    cat_col = "CategoryOriginal" if "CategoryOriginal" in df_subset.columns else "Category"
    summary = summary.rename(columns={cat_col: "Category"})
    summary = summary.sort_values(["CategoryGroup", "Category", "total_amount", "Description"], ascending=[True, True, False, True])
    # Add totals row
    totals = pd.DataFrame(
        {
            "CategoryGroup": ["__ALL__"],
            "Category": ["__ALL__"],
            "Description": ["__TOTAL__"],
            "count": [summary["count"].sum()],
            "total_amount": [summary["total_amount"].sum()],
        }
    )
    summary_with_total = pd.concat([summary, totals], ignore_index=True)
    # Write grouped summary as the canonical master summary file name
    master_out = os.path.join(out_root, f"{base_name}_summary_expenses.csv")
    summary_with_total.to_csv(master_out, index=False)
    print(f"[OK] Wrote grouped (master) summary to: {master_out}")

    # Create per-group detail directory
    out_dir = os.path.join(out_root, f"{base_name}_grouped_tables")
    os.makedirs(out_dir, exist_ok=True)

    # Generate detail tables for each category group
    groups = sorted(df_subset["CategoryGroup"].dropna().unique().tolist())
    for group in groups:
        # Convert group name to safe filename
        group_slug = slugify(group)
        df_group = df_subset[df_subset["CategoryGroup"] == group].copy()
        cols_existing = [col for col in detail_cols if col in df_group.columns]
        df_group_detail = df_group[cols_existing].copy()
        
        # Replace "Category" column with "CategoryOriginal" (original category before remapping)
        if "Category" in df_group_detail.columns and "CategoryOriginal" in df_group.columns:
            df_group_detail["Category"] = df_group["CategoryOriginal"].values

        # Add group total row
        total_row = {col: "" for col in cols_existing}
        if "description" in cols_existing:
            total_row["description"] = "__GROUP_TOTAL__"
        if "Category" in cols_existing:
            total_row["Category"] = ""  # Leave blank for total row
        total_val = df_group_detail["_signed_amount"].sum() if "_signed_amount" in cols_existing else 0
        if "_signed_amount" in cols_existing:
            total_row["_signed_amount"] = total_val
        elif "amount" in cols_existing:
            total_row["amount"] = total_val
        elif "debit" in cols_existing:
            total_row["debit"] = abs(total_val)
        df_group_detail = pd.concat([df_group_detail, pd.DataFrame([total_row])], ignore_index=True)
        df_group_detail.to_csv(os.path.join(out_dir, f"{group_slug}_detail.csv"), index=False)

        # Per-group category summary: show each original category within the group
        group_category_summary = (
            df_group.groupby("CategoryOriginal" if "CategoryOriginal" in df_group.columns else "Category", dropna=False)
            .agg(count=("_signed_amount", "size"), total_amount=("_signed_amount", "sum"))
            .reset_index()
            .sort_values("total_amount", ascending=False)
        )
        # Rename the index column to "Category" for consistency
        col_name = "CategoryOriginal" if "CategoryOriginal" in df_group.columns else "Category"
        group_category_summary = group_category_summary.rename(columns={col_name: "Category"})
        
        # Add group subtotal row
        group_subtotal = {
            "Category": "__GROUP_SUBTOTAL__",
            "count": group_category_summary["count"].sum(),
            "total_amount": group_category_summary["total_amount"].sum(),
        }
        group_category_summary = pd.concat([group_category_summary, pd.DataFrame([group_subtotal])], ignore_index=True)
        group_category_summary.to_csv(os.path.join(out_dir, f"{group_slug}_category_summary.csv"), index=False)

        # Per-group monthly by-category summary: Month × Category totals
        # Use the posted date for month grouping
        if "posted_date" in df_group.columns:
            df_group_dates = df_group.copy()
            # Ensure posted_date is datetime
            df_group_dates["posted_date"] = pd.to_datetime(df_group_dates["posted_date"], errors="coerce")
            df_group_dates["_year_month"] = df_group_dates["posted_date"].dt.strftime("%Y-%m")

            monthly_cat = (
                df_group_dates.groupby(["_year_month", "CategoryOriginal" if "CategoryOriginal" in df_group_dates.columns else "Category"], dropna=False)
                .agg(count=("_signed_amount", "size"), total_amount=("_signed_amount", "sum"))
                .reset_index()
                .rename(columns={"_year_month": "Month"})
                .sort_values(["Month", "total_amount"], ascending=[True, False])
            )
            # Normalize column name
            month_cat_col = "CategoryOriginal" if "CategoryOriginal" in df_group_dates.columns else "Category"
            monthly_cat = monthly_cat.rename(columns={month_cat_col: "Category"})

            # Build rows grouped by month and include a __MONTH_SUBTOTAL__ row per month
            rows = []
            for month, mdf in monthly_cat.groupby("Month", sort=True):
                for _, r in mdf.iterrows():
                    rows.append({
                        "Month": r["Month"],
                        "Category": r["Category"],
                        "count": int(r["count"]),
                        "total_amount": float(r["total_amount"]),
                    })
                # month subtotal
                rows.append({
                    "Month": month,
                    "Category": "__MONTH_SUBTOTAL__",
                    "count": int(mdf["count"].sum()),
                    "total_amount": float(mdf["total_amount"].sum()),
                })

            # Write CSV with one small blank-line-separated block per month.
            out_path = os.path.join(out_dir, f"{group_slug}_monthly_category_summary.csv")
            with open(out_path, "w", newline="") as fh:
                writer = csv.writer(fh)
                # Write a single top-level header once at the very top
                writer.writerow(["Month", "Category", "count", "total_amount"])
                # Iterate months in sorted order
                months = sorted({r["Month"] for r in rows})
                for i, month in enumerate(months):
                    month_rows = [r for r in rows if r["Month"] == month]
                    # single blank line between months (no blank line before first month)
                    if i != 0:
                        writer.writerow([])
                    for r in month_rows:
                        # For subtotal row, omit the month value (empty first cell)
                        if r["Category"] == "__MONTH_SUBTOTAL__":
                            writer.writerow(["", r["Category"], int(r["count"]), float(r["total_amount"])])
                        else:
                            writer.writerow([r["Month"], r["Category"], int(r["count"]), float(r["total_amount"])])
            print(f"[OK] Wrote monthly-by-category summary to: {out_path}")
        else:
            print(f"[WARN] posted_date column not found for group '{group}'; skipping monthly breakdown")

    print(f"[OK] Wrote per-group CSVs (with totals) to: {out_dir}")
    return out_root


__all__ = ["slugify", "write_outputs", "write_grouped_category_outputs"]
